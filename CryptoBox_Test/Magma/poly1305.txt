// Details are here: http://cr.yp.to/mac/poly1305-20050329.pdf

// Copy those from the C code or put an array

r := [ 46, 157, 203, 70, 127, 98, 29, 236, 220, 198, 238, 173, 48, 35, 201, 34 ];
s := [ 38, 209, 204, 112, 165, 173, 225, 134, 62, 229, 62, 116, 115, 74, 219, 49 ];
m := [ 244, 211, 34, 196, 174, 106, 60, 198, 214, 235, 107, 145, 117, 192, 86, 243, 91, 168, 37, 5, 202, 184, 237, 143, 25, 247, 47, 144, 69, 194, 88, 167, 196, 168, 46, 38, 81, 43, 88, 90, 26, 183, 143, 10, 52, 193, 22, 236, 136, 245, 163, 50, 21, 118, 34, 145, 250, 120, 62, 13, 123, 134, 15, 190 ];
mlen := 64 ;

////////////////////////////////////

// R is calculated here.

R :=         r[1]                 + 2^8   * r[2]  + 2^16  * r[3]  + 2^24  * (r[4]  mod 16) +
     2^32 * (r[5]  - r[5]  mod 4) + 2^40  * r[6]  + 2^48  * r[7]  + 2^56  * (r[8]  mod 16) +
     2^64 * (r[9]  - r[9]  mod 4) + 2^72  * r[10] + 2^80  * r[11] + 2^88  * (r[12] mod 16) +
     2^96 * (r[13] - r[13] mod 4) + 2^104 * r[14] + 2^112 * r[15] + 2^120 * (r[16] mod 16);

printf "R = %h\n", R;

////////////////////////////////////

// S is just made a long integer from the input.

S := 0;

for x in [1..16] do
    S := S + s[x] * 2^(8*(x-1));
end for;

printf "S = %h\n", S;

////////////////////////////////////

// q means how many sub blocks of 128 byte you will have

// A message of 64 bytes
q := mlen / 16;

printf "q = %o\n", q;

////////////////////////////////////

// This example is made for 4 blocks so 64 bytes of input
// C values are calculated here manually

C1 := 2^128;
C2 := 2^128;
C3 := 2^128;
C4 := 2^128;

for x in [1..16] do
    C1 := C1 + m[(x)     ] * 2^(8*(x-1));
    C2 := C2 + m[(x) + 16] * 2^(8*(x-1));
    C3 := C3 + m[(x) + 32] * 2^(8*(x-1));
    C4 := C4 + m[(x) + 48] * 2^(8*(x-1));
end for;

printf "C1 = %h\n", C1;
printf "C2 = %h\n", C2;
printf "C3 = %h\n", C3;
printf "C4 = %h\n", C4;

////////////////////////////////////

// The equation that gives the MAC is written here as it is written in the PDF

MAC := (((C1 * R^4 + C2 * R^3 + C3 * R^2 + C4 * R ) mod (2^130-5)) + S) mod 2^128;

printf "MAC = %h\n", MAC;

////////////////////////////////////

// A better method of calculating the MAC is given below
// as it is discussed in the PDF.

ACC := 0;

ACC := (ACC + C1) mod (2^130-5);
ACC := (ACC * R) mod (2^130-5);
ACC := (ACC + C2) mod (2^130-5);
ACC := (ACC * R) mod (2^130-5);
ACC := (ACC + C3) mod (2^130-5);
ACC := (ACC * R) mod (2^130-5);
ACC := (ACC + C4) mod (2^130-5);
ACC := (ACC * R) mod (2^130-5);

ACC := (ACC + S) mod 2^128;

printf "ACC = %h\n", ACC;
